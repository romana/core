// Copyright (c) 2015 Pani Networks
// All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.
package agent

// Some comments on use of mocking framework in helpers_test.go.

import (
	"errors"
	"net"
	"strings"
	"testing"
)

// TestNewChains is checking that detectMissingChains correctly detects which Pani chains
// must be created for given NetIf.
func TestNewChains(t *testing.T) {
	agent := mockAgent()
	// when

	// detectMissingChains calls isChainExist which is reading FakeExecutor
	// isChainExist doesn't care for output but must receive not nil error
	// otherwise it would decide that chain exist already and skip
	E := &FakeExecutor{nil, errors.New("bla"), nil}
	agent.Helper.Executor = E
	ip := net.ParseIP("127.0.0.1")
	fw, _ := NewFirewall(NetIf{"eth0", "A", ip}, &agent)

	newChains := fw.detectMissingChains()

	// expect
	if len(newChains) != 3 {
		t.Error("TestNewChains failed")
	}

	// TODO test case with some chains already exist requires support for
	// stack of output in FakeExecutor
}

// TestCreateChains is checking that CreateChains generates correct OS commands
// for iptables to create firewall chains.
func TestCreateChains(t *testing.T) {
	agent := mockAgent()
	// when

	// CreateChains doesn't care for output and we don't any errors
	// we only want to analize which command generated by the function
	E := &FakeExecutor{nil, nil, nil}
	agent.Helper.Executor = E
	ip := net.ParseIP("127.0.0.1")
	fw, _ := NewFirewall(NetIf{"eth0", "A", ip}, &agent)

	_ = fw.CreateChains([]int{0, 1, 2})

	// expect
	expect := strings.Join([]string{"/sbin/iptables -N pani-T0S0-INPUT",
		"/sbin/iptables -N pani-T0S0-OUTPUT",
		"/sbin/iptables -N pani-T0S0-FORWARD"}, "\n")

	if *E.Commands != expect {
		t.Errorf("Unexpected input from TestCreateChains, expect\n%s, got\n%s", expect, *E.Commands)
	}
}

// TestDivertTraffic is checking that DiverTrafficToPaniIptablesChain generates correct commands for
// firewall to divert traffic into pani chains.
func TestDivertTraffic(t *testing.T) {
	agent := mockAgent()
	// when

	// we only care for recorded commands, no need for fake output or errors
	E := &FakeExecutor{nil, nil, nil}
	agent.Helper.Executor = E
	ip := net.ParseIP("127.0.0.1")
	fw, _ := NewFirewall(NetIf{"eth0", "A", ip}, &agent)

	// 0 is a first standard chain - INPUT
	fw.DiverTrafficToPaniIptablesChain(0)

	// expect
	expect := "/sbin/iptables -A INPUT -i eth0 -j pani-T0S0-INPUT"

	if *E.Commands != expect {
		t.Errorf("Unexpected input from TestDivertTraffic, expect\n%s, got\n%s", expect, *E.Commands)
	}
}

// TestCreateRules is checking that CreateRules generates correct commands to create
// firewall rules.
func TestCreateRules(t *testing.T) {
	agent := mockAgent()
	// when

	// we only care for recorded commands, no need for fake output or errors
	E := &FakeExecutor{nil, nil, nil}
	agent.Helper.Executor = E
	ip := net.ParseIP("127.0.0.1")
	fw, _ := NewFirewall(NetIf{"eth0", "A", ip}, &agent)

	// 0 is a first standard chain - INPUT
	fw.CreateRules(0)

	// expect
	expect := strings.Join([]string{"/sbin/iptables -A pani-T0S0-INPUT -d 172.17.0.1 -j ACCEPT",
		"/sbin/iptables -A pani-T0S0-INPUT -d 127.0.0.1/8 -j ACCEPT",
		"/sbin/iptables -A pani-T0S0-INPUT -p udp --sport 68 --dport 67 -d 255.255.255.255 -j ACCEPT",
		"/sbin/iptables -A pani-T0S0-INPUT -p tcp -m tcp --sport 22 -d 172.17.0.1 -j ACCEPT"},
		"\n")

	if *E.Commands != expect {
		t.Errorf("Unexpected input from TestCreateRules, expect\n%s, got\n%s", expect, *E.Commands)
	}
}

// TestCreateU32Rule is checking that CreateU32Rules generates correct commands to
// create firewall rules.
func TestCreateU32Rules(t *testing.T) {
	agent := mockAgent()
	// when

	// we only care for recorded commands, no need for fake output or errors
	E := &FakeExecutor{nil, nil, nil}

	agent.Helper.Executor = E
	ip := net.ParseIP("127.0.0.1")
	fw, _ := NewFirewall(NetIf{"eth0", "A", ip}, &agent)

	// 0 is a first standard chain - INPUT
	fw.CreateU32Rules(0)

	// expect
	expect := strings.Join([]string{"/sbin/iptables -A pani-T0S0-INPUT -m u32 --u32 12&0xFF00FF00=0x7F000000 && 16&0xFF00FF00=0x7F000000 -j ACCEPT"}, "\n")

	if *E.Commands != expect {
		t.Errorf("Unexpected input from TestCreateU32Rules, expect\n%s, got\n%s", expect, *E.Commands)
	}
}
